---
title: "delaunay faces and meshes"
author: "Helio"
date: "2022-12-25"
output: html_document
---







# landmarks and normalisation

```{r}
require(data.table)
require(ggforce)

library(tidyverse)
View(df_OF_output_land)
df_OF_output_land

colnames(df_OF_output_land)
unique(df_OF_output_land$filename)

# lets start by taking one single subject and plotting the change
# but to do that we fist need to normalise and alligh

library(data.table)

df_OF_output_land$filename
# select one test sample
test_happy <-df_OF_output_land%>%
  subset(filename == "./cut_posed_happy_day2_p6.csv")
  
colnames(df_OF_output_land)
df_OF_output_land
# first binify it
colnames(df_OF_output_land_posed_binned)

unique(df_OF_output_land_posed_binned$bin_frame)

# dcasted
df_OF_output_land_posed_binned
df_OF_output_land_posed_binned_select
# group_by(filename)%>%
#   gather(key, value, -frame, -timestamp,-filename) %>%
#   mutate(coordinate = substr(key,1,1))%>%
#   mutate(lanmark_id = substr(key,3,4)) %>%
#   dcast(filename+lanmark_id+frame+timestamp~coordinate, value.var = "value",  mean)



```

rotate

```{r}

df_OF_output_land_posed_binned_select$Stimuli_frame <- paste0(df_OF_output_land_posed_binned_select$filename,df_OF_output_land_posed_binned_select$bin_frame)

filename_unique<-unique(df_OF_output_land_posed_binned_select$Stimuli_frame)

f = 1
temp_df_bind<- data.frame() # e empty dataframe to store results

for (f in 1:length(filename_unique)) {
  # f = 2
  # video = filename_video[f]
  temp_df <- df_OF_output_land_posed_binned_select%>%
    subset(Stimuli_frame == filename_unique[f])
  
    # start
  message(paste0("running video no_: ", f), paste0("_",filename_unique[f]))


  
  # First, isolate the points of interest (the subject's left and right eyes)
  left_eye  <- temp_df[temp_df$lanmark_id == 42,]
  right_eye <- temp_df[temp_df$lanmark_id == 39,] 
  
  # now find the difference in the y co-ordinates and x co-ordinates between these two points:
  diff_x <- left_eye$x - right_eye$x
  diff_y <- left_eye$y - right_eye$y
  
   message(paste0("angle - ratio - transform"))
  # The arctangent of the ratio will be the angle you need to rotate all the points by:
  theta  <- atan2(-diff_y, diff_x)
  
# print("matrix") 
# To transform the points, you need to create a rotation matrix, which is a specific two-by-two matrix which you can use to rotate the original points:
# 
# enter image description here - https://stackoverflow.com/questions/74493141/align-x-and-y-coordinates-of-face-landmarks-in-r/74493424?noredirect=1#comment131500839_74493424
  
  mat <- matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), 2)

# Now we multiply each x, y point by this matrix to get our rotated points, and write it back into our original data frame:
  temp_df$x_new_norm_rot <- t(apply(temp_df[,7:8], 1, function(x) mat %*% x))[,1]
  temp_df$y_new_norm_rot <- t(apply(temp_df[,7:8], 1, function(x) mat %*% x))[,2] 
   
  message(paste0("bind datasets"))
  
    temp_df_bind<- bind_rows(temp_df_bind,temp_df)
}


```

after this we want to plot again the average landmark position for each expression

```{r}
options(scipen = 999)
# 
# df_OF_output_land_posed_binned_select$subject<- sub(".*_p", "", str_match(df_OF_output_land_posed_binned_select$filename, "p\\s*(.*?)\\s*.csv")[,2])
# df_OF_output_land_posed_binned_select
df_OF_output_land_posed_binned_select_alligned_eyes<- temp_df_bind

# plot alligned landmarks to check
df_OF_output_land_posed_binned_select_alligned_eyes%>%
    filter(bin_frame>40 & bin_frame<75)%>%
  subset(subject == 20)%>% # explore specific subjects
 group_by(lanmark_id,expression)%>%
         summarise_if(is.numeric, mean,na.rm = T)%>%
  ggplot(aes(x = x_new_norm, y = 1-y_new_norm))+
  geom_point()+
    facet_grid(~expression)

# of the above looks right, store average position of ndmarls for plotting
# norm and diff

# now compute difference maps - i.e compute commutative differences for each landmark



# taking too long??
# test_happy_dcast_binned<- 
  # test_happy_dcast %>%
df_OF_output_land_posed_binned_select_alligned_eyes%>%
  group_by(filename, expression,lanmark_id)%>%

  # mutate(x_new_norm = maxnormalize(x),
  #        y_new_norm = maxnormalize(y))%>%
  # compute landmark differences
  group_by(filename,lanmark_id)%>%
  mutate(x_norm_diff= x_new_norm - lag(x_new_norm),
         y_norm_diff= y_new_norm - lag(y_new_norm))%>%
    mutate(x_norm_diff_abs= (x_norm_diff),#decide wherher to absolute or not, i cut the abs for now
         y_norm_diff_abs= (y_norm_diff))%>%
  
  # compute a sum - also consider a rolling sum
   mutate(x_norm_diff_abs_sum= sum(x_norm_diff_abs, na.rm = TRUE),
         y_norm_diff_abs_sum= sum(y_norm_diff_abs, na.rm = TRUE))%>%
  # do a cummulative summ
  # subset(frame == 100)%>%
  mutate(fill_x_y_sum = (x_norm_diff_abs_sum+y_norm_diff_abs_sum)/2)%>% # this is what we are goint to use to colour pints
  
  group_by(filename,lanmark_id)%>%
  #the line below just ignores NA (introduced in lag) which would throw error to cumsum otehrwise
      mutate(cum_x_norm_abs_diff = cumsum(ifelse(is.na(x_norm_diff_abs), 0, x_norm_diff_abs)) + x_norm_diff_abs*0,
             cum_y_norm_abs_diff = cumsum(ifelse(is.na(y_norm_diff_abs), 0, y_norm_diff_abs)) + y_norm_diff_abs*0)%>%
  mutate(cum_x_y_norm_abs_diff_mean_fill = ((cum_x_norm_abs_diff+cum_y_norm_abs_diff)/2))%>%
  
  # normalise the fills
  group_by(subject)%>%
  mutate(cum_x_y_norm_abs_diff_mean_fill_norm = maxnorm(cum_y_norm_abs_diff),
         
         fill_x_y_sum_norm = maxnorm(fill_x_y_sum))%>%
  group_by(filename)%>%
  # this just ensures we have means which we can sumamrise later
  mutate(cum_x_y_norm_abs_diff_mean_fill_norm_mean = mean(cum_x_y_norm_abs_diff_mean_fill_norm, na.rm = T),
         fill_x_y_sum_norm_mean - mean(fill_x_y_sum_norm, na.rm = T))

# might not need to summarise below
  #   group_by(filename, expression, bin_frame, lanmark_id)%>% #posed.spoken
  # summarise_if(is.numeric, mean, na.rm = T)
  


# summarise for del and vor
df_OF_output_land_posed_binned_select_alligned_eyes
 filter(bin_frame>40 & bin_frame<75)%>%
  # subset(subject == 20)%>% # explore specific subj
  group_by(filename, expression, lanmark_id)%>% #posed.spoken
  summarise_if(is.numeric, mean, na.rm = T)
 
 # 
 
```

try del amnd vor plots

```{r}

# one colour per triangle
tri <- triang.list(deldir(iris$Sepal.Length, iris$Sepal.Width))
do.call(rbind, lapply(seq_along(tri), 
                      function(x) {
  data.frame(Sepal.Length = tri[[x]]$x, Sepal.Width = tri[[x]]$y, 
             Petal.Length = mean(iris$Petal.Length[tri[[x]]$ptNum]),
             tri = x)
  })) |>
  ggplot(aes(Sepal.Length, Sepal.Width)) +
  geom_polygon(aes(fill = Petal.Length, group = tri)) 

# fil gradients
Additional

To gradient fill your triangles, probably best to draw blank triangles over a 2D interpolation:

library(interp)
library(ggforce)

interp(iris$Sepal.Length, iris$Sepal.Width, iris$Petal.Length, 
              duplicate = "mean", nx = 1000, ny = 1000) |>
  interp2xyz() |>
  as.data.frame() |>
  setNames(names(iris)[1:3]) |>
  ggplot(aes(Sepal.Length, Sepal.Width)) +
  geom_raster(aes(fill = Petal.Length)) +
  scale_fill_continuous(na.value = NA) +
  geom_delaunay_tile(data = iris, fill = NA, color = "#00000050")

# traidional vorplot

test_happy_dcast_summ%>%
  group_by(expression, lanmark_id)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  
  ggplot(aes(x = x_new_norm, y = 1-y_new_norm))+
  geom_point()+
  facet_grid(~expression)
  
    ggplot(aes(x = x_new_norm, y = 1-y_new_norm, fill = cum_x_y_norm_abs_diff_mean_fill_norm,
               colour = cum_x_y_norm_abs_diff_mean_fill_norm))+

     # geom_point(aes(colour = cum_x_y_norm_abs_diff_mean_fill_norm), colour = "white")+
    
   geom_voronoi_tile(aes(fill = cum_x_y_norm_abs_diff_mean_fill_norm), colour =NA)+
  # geom_delaunay_segment2( colour = "white",alpha = .2)+
   geom_point(aes(y = mean(1-y_new_norm)), colour = "white",size = .5,alpha = .5)+
  # geom_delaunay_tile(aes(colour = cum_x_y_norm_abs_diff_mean_fill_norm))+
  # ggforce::stat_delvor_summary()

     scale_color_viridis_c(option = "magma")+
  scale_fill_viridis_c(option = "magma")+
    facet_grid(~expression)
```


```{r}

unique(test_happy_dcast$filename)
nrow(test_happy_dcast_binned)

nrow(test_happy_dcast)

# redo NMF with
df_OF_output_land_posed_binned_select_alligned_eyes
```


# 
test_happy_dcast_binned$expression
test_happy_dcast$posed.spoken<- sapply(strsplit(test_happy_dcast$filename, "_"), function(x) x[2])
test_happy_dcast$expression <-sapply(strsplit(test_happy_dcast$filename, "_"), function(x) x[3])

# sumamrise_bin
colnames(test_happy_dcast_binned)
test_happy_dcast_binned1<- test_happy_dcast_binned%>%
  group_by(filename, expression, bin_frame, posed.spoken, lanmark_id)%>%
  summarise_if(is.numeric, mean, na.rm = T)
  

test_happy_dcast_summ<- test_happy_dcast%>%
    subset(posed.spoken == "posed")%>%
  subset(frame > 100 & frame <200)%>%
      group_by(filename,lanmark_id,expression)%>%

         summarise_if(is.numeric, mean,na.rm = T)

bound_plot<- cbind(test_happy_dcast_summ$x_new_norm,test_happy_dcast_summ$y_new_norm)
bound_plot


paneled
unique(test_happy_dcast$frame)



  
    test_happy_dcast
  
  
# 
# library(deldir)
#   frame_1<- subset(test_happy_dcast, test_happy_dcast$frame == 1)
# dxy <- deldir(frame_1$x_new_norm, frame_1$y_new_norm)

maxnormalize <- function(x, ...) {
    return((x - min(x, ...)) /(max(x, ...) - min(x, ...))) }

df_OF_output_land_f10_dcast_norm<- df_OF_output_land_f10_dcast%>%
    group_by(filename,frame)%>%
  mutate(x_new_norm = maxnormalize(x),
         y_new_norm = maxnormalize(y))

?cowplot::get_panel
get_panel1<-cowplot::get_panel(paneled)

# try and estimate y and x separately

library(data.table)
colnames(lan_AU_comp_paired)

lan_AU_comp_paired_dcast<-setDT(lan_AU_comp_paired)%>%
dcast(lanmark_id~comp, value.var = c('value', 'coef'), mean)


test_happy_dcast_summ_paired_test<-left_join(
test_happy_dcast_summ,lan_AU_comp_paired_dcast)
unique(df_OF_output_land_posed_binned_select$filename)

df_OF_output_land_posed_binned_select$subject<- sub(".*_p", "", str_match(df_OF_output_land_posed_binned_select$filename, "p\\s*(.*?)\\s*.csv")[,2])

df_OF_output_land_posed_binned_select$subject

df_OF_output_land_posed_binned_select%>%
    filter(bin_frame>40 & bin_frame<75)%>%
  subset(subject == 20)%>%
 group_by(lanmark_id,expression)%>%
         summarise_if(is.numeric, mean,na.rm = T)%>%
  ggplot(aes(x = x_new_norm, y = 1-y_new_norm))+
  geom_point()+
    facet_grid(~expression)

unique(df_OF_output_land_posed_binned)

test_happy_dcast_summ_paired_test%>%
   group_by(lanmark_id,expression)%>%
         summarise_if(is.numeric, mean,na.rm = T)%>%
  # subset()
    ggplot(aes(x = x_new_norm, y = 1-y_new_norm, fill = cum_x_y_norm_abs_diff_mean_fill_norm*coef_3*value_3,
               colour = cum_x_y_norm_abs_diff_mean_fill_norm*coef_3*value_3))+

     geom_point(aes(colour = cum_x_y_norm_abs_diff_mean_fill_norm), colour = "white")+
    
   geom_voronoi_tile(aes(fill = cum_x_y_norm_abs_diff_mean_fill_norm*coef_3*value_3), colour =NA)+
  # geom_delaunay_segment2( colour = "white",alpha = .2)+
   geom_point(aes(colour = cum_x_y_norm_abs_diff_mean_fill_norm), colour = "white",size = .5,alpha = .5)+

     scale_color_viridis_c(option = "magma")+
  scale_fill_viridis_c(option = "magma")+
    facet_grid(~expression)
  
    test_happy_dcast
  
```

stack question
```{r}
iris


ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_voronoi_tile(aes(fill = Petal.Length))
# Delaunay triangles
ggplot(iris, aes(Sepal.Length, Sepal.Width,fill = Petal.Length)) +
  geom_delaunay_tile()

# colouring lines
ggplot(iris, aes(Sepal.Length, Sepal.Width,colour = Petal.Length)) +
  geom_delaunay_segment2()


# deldir - let's examine the ouput of a delaunay trianglation
library(deldir)
?deldir
deldir_output<-deldir(iris$Sepal.Length, iris$Sepal.Width, plot=TRUE)
deldir_output
```



```{r}

test_happy_dcast
df_OF_output_land_posed_binned_select
lan_AU_comp_paired_W


colnames(lan_AU_comp_paired_W)
colnames(test_happy_dcast)
unique(lan_AU_comp_paired_W2$bin_frame)
# 79,070,400 
# test_happy_dcast$frame
colnames(lan_AU_comp_paired_W)


lan_AU_comp_paired_W %>%
      group_by(filename,bin_frame)%>%
  mutate(x_new_norm = maxnormalize(x),
         y_new_norm = maxnormalize(y))%>%
  group_by(filename,lanmark_id)%>%
  mutate(x_norm_diff= x_new_norm - lag(x_new_norm),
         y_norm_diff= y_new_norm - lag(y_new_norm))%>%
    mutate(x_norm_diff_abs= (x_norm_diff),
         y_norm_diff_abs= (y_norm_diff))%>%
  # compute a summ - also consider a roling sum
   mutate(x_norm_diff_abs_sum= sum(x_norm_diff_abs, na.rm = TRUE),
         y_norm_diff_abs_sum= sum(y_norm_diff_abs, na.rm = TRUE))%>%
  
  mutate(fill_x_y = (x_norm_diff_abs_sum+y_norm_diff_abs_sum)/2)%>%
  group_by(filename,lanmark_id)%>%
  #the line below just ignores NA (introduced in lag) which would throw error to cumsum otehrwise
      mutate(cum_x_norm_abs_diff = cumsum(ifelse(is.na(x_norm_diff_abs), 0, x_norm_diff_abs)) + x_norm_diff_abs*0,
             cum_y_norm_abs_diff = cumsum(ifelse(is.na(y_norm_diff_abs), 0, y_norm_diff_abs)) + y_norm_diff_abs*0)%>%
  mutate(cum_x_y_norm_abs_diff_mean_fill = ((cum_x_norm_abs_diff+cum_y_norm_abs_diff)/2))%>%
  # just y
  mutate(cum_x_y_norm_abs_diff_mean_fill_norm = maxnormalize(cum_y_norm_abs_diff))
```

NMF of landmarks?

```{r}

test_happy_dcast
# bin
unique(test_happy_dcast$posed.spoken)

df_OF_output_land_posed_binned <-test_happy_dcast%>%
    subset(posed.spoken == "posed")%>%
  group_by(filename, expression,lanmark_id)%>%
  mutate(bin_frame = cut(frame, 50, labels = FALSE))%>%
  group_by(filename,bin_frame,expression,lanmark_id)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)

colnames(df_OF_output_land_posed_binned)
 df_OF_output_land_posed_binned_select<- df_OF_output_land_posed_binned[,c(1:6,9:10)]

 colnames(df_OF_output_land_posed_binned_select)
 # df_OF_output_AUsW_unblind_posed_binned
 
 unique(df_OF_output_land_posed_binned_select$lanmark_id)
 
 df_OF_output_land_posed_binned_select$lanmark_id<- as.numeric(df_OF_output_land_posed_binned_select$lanmark_id)
 df_OF_output_land_posed_binned_select%>%
  group_by(filename,bin_frame)%>%
  arrange(as.numeric(lanmark_id),bin_frame)
df_OF_output_land_posed_binned_select_dcast <- setDT(df_OF_output_land_posed_binned_select)%>%
  # group_by(filename)%>%
  # arrange(bin_frame,as.numeric(as.factor(lanmark_id)) ) %>%
  # setDT()%>%
  dcast(filename+bin_frame+expression+frame~lanmark_id, value.var = c("x_new_norm","y_new_norm"))

df_OF_output_land_posed_binned_select_dcast

```

NMF on landmarks

```{r}
df_OF_output_land_posed_binned_select_dcast
library(NMF)

colnames(df_OF_output_land_posed_binned_select_dcast)
colnames(df_OF_output_land_posed_binned_select_dcast)
res_k3_land <- NMF::nmf(df_OF_output_land_posed_binned_select_dcast[,5:140], r = 3, 
                  nrun = 30, #
                  seed=123456,
                 .options = list( 'v')) #


NMF::plot(res_k3_land)
NMF::basis(res_k3_land)
NMF::aheatmap(res_k3_land)

NMF::basis(res_k3_land)
coefmap(res_k3_land)
basismap(res_k3_land)


NMF::coefmap(res_k3, scale = "none")
plot(res_k3_land)

res_k3_land@fit@W
res_k3_land_H<- as.data.frame(res_k3_land@fit@H)%>%
  gather(key, value)%>%
  mutate(comp = rep(seq(1:3), times = 136))%>%
  mutate(lanmark_id = substr(key,12,13))%>%
  mutate(coord = substr(key,1,1))
options(scipen = 999)

res_k3_land_H_dcast<-res_k3_land_H%>%
   group_by(comp)%>%
  mutate(value = maxnormalize(value))%>%
  setDT()%>%
  dcast(comp+ lanmark_id ~coord, value.var = "value")
 
  ggplot(aes(x,1-y, colour = (x+(1-y))/2))+
  geom_point()+
  scale_color_viridis_c(option = "magma")+
  facet_grid(~comp)
  
  res_k3_land_H_dcast
  
res_k3_land_W<-  as.data.frame(res_k3_land@fit@W)%>%
    mutate(bin_frame = df_OF_output_land_posed_binned_select_dcast$bin_frame)%>%
    mutate(filename = df_OF_output_land_posed_binned_select_dcast$filename)%>%
       mutate(expression = df_OF_output_land_posed_binned_select_dcast$expression)

colnames(res_k3_land_W)
res_k3_land_W_gath<- res_k3_land_W%>%
   gather(comp, value,-bin_frame,  -filename,-expression)%>%
  mutate(comp = substr(comp,2,2))

res_k3_land_H_dcast$comp<- as.character(res_k3_land_H_dcast$comp)

# plot new
left_join(res_k3_land_W_gath, res_k3_land_H_dcast)%>%
  group_by(comp)%>%
  mutate(value = maxnormalize(value))%>%
  mutate(x_new = value * x,
         y_new = value * y)%>%
  
  group_by(expression,lanmark_id,comp)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
    ggplot(aes(x_new,1-y_new, colour = comp))+
  geom_point(alpha = .5)+
  # scale_color_viridis_c(option = "magma")+
  facet_grid(~comp)
  


   group_by(comp)%>%
  mutate(value = maxnormalize(value))%>%
  setDT()%>%
  dcast(comp+ lanmark_id ~coord, value.var = "value")
```


above not quite there yet

let's see correlations

```{r}
# correlation between land mark and AUS
df_OF_output_AUsW_unblind_posed_binned1
df_OF_output_land_posed_binned_select_dcast
colnames(df_OF_output_land_posed_binned_select_dcast)
df_AU_land_bin<- left_join(df_OF_output_AUsW_unblind_posed_binned1,df_OF_output_land_posed_binned_select_dcast,
          by = c("filename", "expression", "bin_frame"))

df_AU_land_bin

# Select the two groups of variables
colnames(df_AU_land_bin)
vars_x <- select(df_AU_land_bin, 16:32)

# we can just take y to start
vars_y <- select(df_AU_land_bin, 119:186)

# Compute the correl
cor(vars_x, vars_y, use="pairwise.complete.obs")

# Compute the correlations as before
cor_matrix <- cor(vars_x, vars_y, use="pairwise.complete.obs")

# Visualize the correlations
library(corrplot)
corrplot(cor_matrix)

# selected_vars <- vars_y[which(abs(cor_matrix[,1]) > .3),]
# 
# vars_y[,which(abs(cor_matrix[1,]) > .3)]
# 
# selected_vars

above_thresh<- as.data.frame(abs(cor_matrix))%>%
  summarise_if(is.numeric, max, na.rm = T)%>%
  gather(key, values)
  subset(values>.3)

View(above_thresh)


cor_matrix
df_OF_output_land_posed_binned
cor_matrix_tresh<- as.data.frame(abs(cor_matrix))
  select(c(above_thresh$key))
  
cor_matrix_tresh_repl<- replace(cor_matrix_tresh, cor_matrix_tresh < .3, 0)


cor_matrix_tresh_repl_gath<- cor_matrix_tresh_repl%>%
  mutate(AU = rownames(cor_matrix_tresh_repl))%>%
  gather(land_y, value,-AU)
  
colnames(cor_matrix_tresh_repl_gath)

unique(cor_matrix_tresh_repl_gath$land_y)

# combine with the plots
NMF3_k3_res<- as.data.frame(res_k3@fit@H)%>%
  mutate(component = 1:n())%>%
  gather(AU, coef, -component)%>%
  group_by(component)%>%
  mutate(max_comp = max(coef),
         coef = coef/max_comp,
         # AU = substring(AU,8,40),
         AU_code = substring(AU,4,5)
         )

NMF3_k3_res$comp<- NMF3_k3_res$component
lan_AU_comp_paired<- left_join(NMF3_k3_res$,cor_matrix_tresh_repl_gath)
# avoid multiplication y zero

lan_AU_comp_paired$value<- lan_AU_comp_paired$value+0.0001

lan_AU_comp_paired$lanmark_id<- substr(lan_AU_comp_paired$land_y, 12,13)
# 
# group_by(as.factor(AU))%>%
#     arrange(desc(value))
  
```


go back tothebig dataset at the start
```{r}

save(lan_AU_comp_paired,lan_AU_comp_paired_W,
     df_OF_output_land_posed_binned_select,
     
     file = "part_land_AU_testdata.Rdata")
lan_AU_comp_paired



lan_AU_comp_paired

lan_AU_comp_paired$comp<- as.character(lan_AU_comp_paired$comp)

lan_AU_comp_paired$coef
lan_AU_comp_paired_W<- left_join(res_k3_land_W_gath,lan_AU_comp_paired, by = "comp")


colnames(lan_AU_comp_paired_W)
lan_AU_comp_paired_W$correlation<- lan_AU_comp_paired_W$value.y

colnames(lan_AU_comp_paired_W)

lan_AU_comp_paired_W

unique(lan_AU_comp_paired_W$bin_frame)

df_OF_output_land_posed_binned_select$lanmark_id<- as.character(df_OF_output_land_posed_binned_select$lanmark_id)

df_OF_output_land_posed_binned

colnames(df_OF_output_land_posed_binned_select)

colnames(lan_AU_comp_paired_W2)
unique(lan_AU_comp_paired_W$bin_frame)
unique(df_OF_output_land_posed_binned_select$bin_frame)

lan_AU_comp_paired_W2<- left_join( lan_AU_comp_paired_W%>%
                                    subset(bin_frame>40 & bin_frame<80) %>%
                                    group_by(filename,expression,comp, lanmark_id, bin_frame)%>%
                                    summarise_if(is.numeric, mean, na.rm =T), df_OF_output_land_posed_binned_select%>%
                                      subset(bin_frame>40 & bin_frame<80)%>%
                                    group_by(filename,expression,lanmark_id,bin_frame)%>%
                                    summarise_if(is.numeric, mean, na.rm =T))

lan_AU_comp_paired_W2
# 79,070,400 
# 1,550,400


unique(lan_AU_comp_paired_W2$filename)

max(lan_AU_comp_paired_W2$coef)
max(lan_AU_comp_paired_W2$value.x)

lan_AU_comp_paired_W2
# res_k3
table(is.na(lan_AU_comp_paired_W2$coef))
table(is.na(lan_AU_comp_paired_W2$value.x))


lan_AU_comp_paired_W2%>%
      ungroup()%>%

  mutate(fill_coef = (coef*value.y)*correlation) %>%
   # group_by(expression,comp)%>%
  # mutate(fill_coef = fill_coef/max(fill_coef, na.rm =T)) %>%
  
group_by(filename,lanmark_id,expression,comp)%>%
         summarise_if(is.numeric, mean,na.rm = T)%>%
  ungroup()%>%
    ggplot(aes(x = x_new_norm, y = 1-y_new_norm,
             # value.x - time
             # $coef * basis
               colour = fill_coef))+

     geom_point(alpha = .1)+
       scale_color_viridis_c(option = "magma")+
  # scale_fill_viridis_c(option = "magma")+
      facet_grid(~comp)+
    
   geom_voronoi_tile(aes(fill = fill_coef), colour =NA)+
  geom_delaunay_segment2( colour = "white",alpha = .2)+
   geom_point(aes(colour = fill_coef), colour = "white",size = .5,alpha = .5)


unique(lan_AU_comp_paired_W2)
unique(lan_AU_comp_paired_W2$bin_frame)
lan_AU_comp_paired_W2%>%
# test_happy_dcast%>%
    # subset(posed.spoken == "posed")%>%
  subset(frame > 100 & frame <200)%>%
      group_by(lanmark_id,expression)%>%

         summarise_if(is.numeric, mean,na.rm = T)%>%
  ungroup()%>%
    ggplot(aes(x = x_new_norm, y = 1-y_new_norm, fill = cum_x_y_norm_abs_diff_mean_fill_norm,
               colour = cum_x_y_norm_abs_diff_mean_fill_norm))+

     geom_point(aes(colour = cum_x_y_norm_abs_diff_mean_fill_norm), colour = "white")+
    
   geom_voronoi_tile(aes(fill = cum_x_y_norm_abs_diff_mean_fill_norm), colour =NA)+
  geom_delaunay_segment2( colour = "white",alpha = .2)+
   geom_point(aes(colour = cum_x_y_norm_abs_diff_mean_fill_norm), colour = "white",size = .5,alpha = .5)+
  # geom_delaunay_tile(aes(colour = cum_x_y_norm_abs_diff_mean_fill_norm))+
  # ggforce::stat_delvor_summary()

     scale_color_viridis_c(option = "magma")+
  scale_fill_viridis_c(option = "magma")+
    facet_grid(~expression)

# 
# rm(test_dtw,rnames, pd,pd1, ph,ph1)

install.paclages("interp")
```


<!-- proper alligments etc -->
maxnormalize <- function(x, ...) {
    return((x - min(x, ...)) /(max(x, ...) - min(x, ...))) }

df_OF_output_land_f10_dcast_norm<- df_OF_output_land_f10_dcast%>%
    group_by(filename,frame)%>%
  mutate(x_new_norm = maxnormalize(x),
         y_new_norm = maxnormalize(y))

df_OF_output_land_f10_dcast_norm%>%
  group_by(lanmark_id)%>%
summarise_if(is.numeric, mean, na.rm = T)%>%
  ggplot(aes(x_new_norm, y_new_norm))+
  geom_point()+
  ylim(1,0)

df_OF_output_land_f10_dcast_normagg<-df_OF_output_land_f10_dcast_norm%>%
  group_by(lanmark_id)%>%
summarise_if(is.numeric, mean, na.rm = T)

# First, isolate the points of interest (the subject's left and right eyes)

left_eye  <- df_OF_output_land_f10_dcast_normagg[df_OF_output_land_f10_dcast_normagg$lanmark_id == 42,]
right_eye <- df_OF_output_land_f10_dcast_normagg[df_OF_output_land_f10_dcast_normagg$lanmark_id == 39,] 

# Now find the difference in the y co-ordinates and x co-ordinates between these two points:

diff_x <- left_eye$x_new_norm - right_eye$x_new_norm
diff_y <- left_eye$y_new_norm - right_eye$y_new_norm


# The arctangent of the ratio will be the angle you need to rotate all the points by:

theta  <- atan2(-diff_y, diff_x)

mat <- matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), 2)

df_OF_output_land_f10_dcast_normagg[,8:9] <- t(apply(df_OF_output_land_f10_dcast_normagg[,6:7], 1, function(x) mat %*% x))


df_OF_output_land_f10_dcast_normagg %>%
  ggplot(aes(V1, V2, label = lanmark_id)) + 
  geom_point(color = 'gray') +
  geom_text() +
  scale_y_reverse() +
  theme_bw()


df_OF_output_land_f10_dcast_normagg


install.packages("ggvoronoi")

?ggvoronoi::stat_voronoi
write_csv(df_OF_output_land_f10_dcast_normagg, "df_OF_output_land_f10_dcast_normagg.csv")
df_OF_output_land_f10_dcast_normagg %>%
  arrange(lanmark_id)%>%
  ggplot(aes(V1, V2, label = lanmark_id)) + 
  ggvoronoi::stat_voronoi(geom="path", outline = c(df_OF_output_land_f10_dcast_normagg$V1, df_OF_output_land_f10_dcast_normagg$V2)) +
  geom_point()+
  ylim(1,0)


write_csv(pca_AUs, "pca_AUs.csv")


# coded landmarks
library(readxl)
codeLandmarksAUs <- read_excel("codeLandmarksAUs.xlsx")
View(codeLandmarksAUs)
codeLandmarksAUs%>%
  arrange(lanmark_id)%>%
  ggplot(aes(V1, V2, label = lanmark_id)) + 
  # geom_path()+
  # ggvoronoi::stat_voronoi(geom="path", outline = c(df_OF_output_land_f10_dcast_normagg$V1, df_OF_output_land_f10_dcast_normagg$V2)) +
  geom_point()+
  ylim(1,0)+
  theme_bw()

codeLandmarksAUs


df_OF_output_AUsW_unblind_posed_binned1

library(readxl)
LANDMARKNMF <- read_excel("LANDMARKNMF.xlsx")
View(LANDMARKNMF)

LANDMARKNMF[is.na(LANDMARKNMF)] <- 0

pairing AOIs to landmarks

Lanmarking
```{r}
library(readxl)
LANDMARKNMF <- read_excel("Library/CloudStorage/GoogleDrive-helioclemente.c@gmail.com/My Drive/2022 - University Of Birmingham/HaloStudy/Data/LANDMARKNMF.xlsx")
View(LANDMARKNMF)
LANDMARKNMF


NMFresk3test<- as.data.frame(res_k3@fit@H)%>%
  mutate(component = 1:n())%>%
  gather(AU, coef, -component)%>%
  group_by(component)%>%
  mutate(max_comp = max(coef),
         coef = coef/max_comp,
         # AU = substring(AU,8,40),
         AU_code = substring(AU,4,5)
         )%>%
  arrange(AU_code)



LANDMARKNMF


NMFresk3test

LANDMARKNMF<- LANDMARKNMF1
colnames(LANDMARKNMF)
colnames(LANDMARKNMF[,c(1,8:9,12:31)])

LANDMARKNMF_dcast<- LANDMARKNMF[,c(1,8:9,12:31)]%>%
gather(AU, land1_0,-c(1:3,21:23))%>%
gather(comp, land1_0_nmf, -c(1:3,7:8))

library(ggvoronoi)

left_join(LANDMARKNMF_dcast,NMFresk3test)%>%
  mutate(V1_1 = if_else(land1_0_nmf == 1, V1, NULL),
         V2_2 = if_else(land1_0_nmf == 1, V2, NULL)) %>%
  group_by(lanmark_id, component, AU)%>%
  summarise_if(is.numeric, mean, na.rm = T) %>%
  mutate(coef2 = if_else(land1_0_nmf == 1, coef,0))%>%
  ggplot(aes(V1_1, V2_2, color = coef2))+
  geom_point(aes(size = coef2), alpha = .5)+
  # geom_point( aes(x = V1_1, y = V2_2, color = coef2, fill = coef2))+
  ggvoronoi::stat_voronoi(geom="path")+
  geom_point(aes(x = V1, y = V2))+
  # geom_point(aes(size = coef), alpha = .1)+
  ylim(1,0)+
  facet_grid(~component)+
  scale_color_viridis_c(option = "magma")

  
LANDMARKNMF_dcast

# 

install.packages("ggforce")
library(ggforce)
left_join(LANDMARKNMF_dcast,NMFresk3test)%>%
  mutate(V1_1 = if_else(land1_0 == 1, V1, NULL),
         V2_2 = if_else(land1_0 == 1, V2, NULL)) %>%
  # group_by(lanmark_id)%>%
  # summarise_if(is.numeric, mean, na.rm = T) %>%
  mutate(coef2 = if_else(land1_0 == 1, coef,0))%>%
  ggplot(aes(V1_1, V2_2, color = coef2, fill=coef2 ))+
  geom_point(aes(size = coef2), alpha = .5)+
    # ggvoronoi::stat_voronoi(geom="path" )
  # geom_point( aes(x = V1_1, y = V2_2, color = coef2, fill = coef2))+

  geom_point(aes(x = V1, y = V2))+
  # geom_point(aes(size = coef), alpha = .1)+
  ylim(1,0)+
  facet_grid(~component)+
    geom_delaunay_tile(aes(x =V1, V2, fill = lanmark_id), alpha = 0.3, colour = 'black')+
  # geom_delaunay_segment2()+
  scale_color_viridis_c(option = "magma")

NMFresk3test$component
LANDMARKNMF_dcast$component<- as.numeric(substr(LANDMARKNMF_dcast$comp,4,4))

left_join(LANDMARKNMF_dcast,NMFresk3test)%>%
  mutate(V1_1 = if_else(land1_0 == 1, V1, NULL),
         V2_2 = if_else(land1_0 == 1, V2, NULL)) %>%
  # group_by(lanmark_id)%>%
  # summarise_if(is.numeric, mean, na.rm = T) %>%
  mutate(coef2 = if_else(land1_0 == 1, coef,0))%>%
  ggplot(aes(V1_1, V2_2, color = coef2, fill=coef2 ))+
  geom_point(aes(size = coef2), alpha = .5)+
    # ggvoronoi::stat_voronoi(geom="path" )
  # geom_point( aes(x = V1_1, y = V2_2, color = coef2, fill = coef2))+

  geom_point(aes(x = V1, y = V2))+
  # geom_point(aes(size = coef), alpha = .1)+
  ylim(1,0)+
  facet_grid(~component)+
    geom_delaunay_tile(aes(x =V1, V2), alpha = 0.1, colour = 'black')+
      geom_delaunay_segment2(aes(x =V1, V2, colour = coef2))+
  # geom_delaunay_segment2()+
  scale_color_viridis_c(option = "magma")

```
